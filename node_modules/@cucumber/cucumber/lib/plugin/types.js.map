{"version":3,"file":"types.js","sourceRoot":"","sources":["../../src/plugin/types.ts"],"names":[],"mappings":"","sourcesContent":["import { Writable } from 'node:stream'\nimport { Envelope } from '@cucumber/messages'\nimport { ILogger } from '../environment'\nimport { IFilterablePickle } from '../filter'\nimport { IResolvedPaths } from '../paths'\n\n/**\n * The operation Cucumber is doing in this process\n * @public\n * @remarks\n * `loadSources` and `loadSupport` are generally used as preflight operations\n * for complex use cases. `runCucumber` is the one where tests are actually\n * executed.\n */\nexport type PluginOperation = 'loadSources' | 'loadSupport' | 'runCucumber'\n\n/**\n * Subset of the environment available to plugins\n * @public\n */\nexport type CoordinatorEnvironment = {\n  /**\n   * Working directory for the project\n   */\n  cwd: string\n  /**\n   * Writable stream where the test run's warning/error output is written\n   * and plugins can write to directly if required\n   */\n  stderr: Writable\n  /**\n   * Environment variables\n   */\n  env: Record<string, string | undefined>\n}\n\n/**\n * Keys for event handlers that plugins can register\n * @public\n */\nexport type CoordinatorEventKey = 'message' | 'paths:resolve'\n\n/**\n * Keys for transforms that plugins can register\n * @public\n */\nexport type CoordinatorTransformKey = 'pickles:filter' | 'pickles:order'\n\n/**\n * Mapping of event keys to their value types\n * @public\n */\nexport type CoordinatorEventValues = {\n  message: Readonly<Envelope>\n  'paths:resolve': Readonly<IResolvedPaths>\n}\n\n/**\n * Mapping of transform keys to their value types\n * @public\n */\nexport type CoordinatorTransformValues = {\n  'pickles:filter': Readonly<Array<IFilterablePickle>>\n  'pickles:order': Readonly<Array<IFilterablePickle>>\n}\n\n/**\n * Handler function for a coordinator event\n * @public\n * @remarks\n * You can do async work here, but Cucumber will not await the Promise.\n */\nexport type CoordinatorEventHandler<K extends CoordinatorEventKey> = (\n  value: CoordinatorEventValues[K]\n) => void\n\n/**\n * Transformer function for a coordinator transform\n * @remarks\n * Don't try to modify the original value. Return a transformed value, or\n * `undefined` to pass through unchanged.\n * @public\n */\nexport type CoordinatorTransformer<K extends CoordinatorTransformKey> = (\n  value: CoordinatorTransformValues[K]\n) => PromiseLike<CoordinatorTransformValues[K]> | CoordinatorTransformValues[K]\n\n/**\n * Context object passed to a plugin's coordinator function\n * @public\n */\nexport type CoordinatorContext<OptionsType> = {\n  /**\n   * The operation Cucumber is doing in this process\n   */\n  operation: PluginOperation\n  /**\n   * Register an event handler\n   */\n  on: <EventKey extends CoordinatorEventKey>(\n    event: EventKey,\n    handler: CoordinatorEventHandler<EventKey>\n  ) => void\n  /**\n   * Register a transformer\n   */\n  transform: <EventKey extends CoordinatorTransformKey>(\n    event: EventKey,\n    handler: CoordinatorTransformer<EventKey>\n  ) => void\n  /**\n   * Options for the plugin\n   */\n  options: OptionsType\n  /**\n   * Logger for emitting user-facing messages or diagnostics\n   */\n  logger: ILogger\n  /**\n   * Subset of the environment\n   */\n  environment: CoordinatorEnvironment\n}\n\n/**\n * Optional cleanup function returned by a plugin coordinator\n * @public\n */\nexport type PluginCleanup = () => PromiseLike<void> | void\n\n/**\n * A plugin that can subscribe to events and register transforms\n * @public\n */\nexport type Plugin<OptionsType = any> = {\n  type: 'plugin'\n  /**\n   * Coordinator function called during initialization\n   * @remarks\n   * Can do async work, and the Promise will be awaited. Can optionally return\n   * a cleanup function to be called when Cucumber is about to exit.\n   */\n  coordinator: (\n    context: CoordinatorContext<OptionsType>\n  ) => PromiseLike<PluginCleanup | void> | PluginCleanup | void\n  /**\n   * Optional key to extract plugin-specific options from the root options object\n   */\n  optionsKey?: string\n}\n\nexport type FormatterPluginContext<OptionsType> = {\n  on: (key: 'message', handler: (value: Envelope) => void) => void\n  options: OptionsType\n  logger: ILogger\n  stream: NodeJS.WritableStream\n  write: (buffer: string | Uint8Array) => void\n  directory?: string\n}\n\nexport type FormatterPluginFunction<OptionsType> = (\n  context: FormatterPluginContext<OptionsType>\n) => PromiseLike<PluginCleanup | void> | PluginCleanup | void\n\nexport type FormatterPlugin<OptionsType = any> = {\n  type: 'formatter'\n  formatter: FormatterPluginFunction<OptionsType>\n  optionsKey?: string\n}\n"]}