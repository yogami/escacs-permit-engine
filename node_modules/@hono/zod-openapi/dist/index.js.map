{"version":3,"file":"index.js","names":["validators: MiddlewareHandler[]","mw: MiddlewareHandler","e: any","errorIfNotExhaustive: never","updatedPaths: Record<string, any>"],"sources":["../src/zod-typeguard.ts","../src/index.ts"],"sourcesContent":["import type { ZodType as ZodTypeV3 } from 'zod/v3'\nimport type { ZodType as ZodTypeV4 } from 'zod/v4'\n\nfunction isObject(x: unknown): x is Record<string, unknown> {\n  return typeof x === 'object' && x !== null\n}\n\nexport function isZod(x: unknown): x is ZodTypeV3 | ZodTypeV4 {\n  if (!x) return false\n  if (!isObject(x)) return false\n  return (\n    typeof x.parse === 'function' &&\n    typeof x.safeParse === 'function' &&\n    typeof x.parseAsync === 'function' &&\n    typeof x.safeParseAsync === 'function'\n  )\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport type {\n  RouteConfig as RouteConfigBase,\n  ZodContentObject,\n  ZodMediaTypeObject,\n  ZodRequestBody,\n} from '@asteasolutions/zod-to-openapi'\nimport {\n  OpenAPIRegistry,\n  OpenApiGeneratorV3,\n  OpenApiGeneratorV31,\n  extendZodWithOpenApi,\n  getOpenApiMetadata,\n} from '@asteasolutions/zod-to-openapi'\nimport { zValidator } from '@hono/zod-validator'\nimport { Hono } from 'hono'\nimport type {\n  Context,\n  Env,\n  ErrorHandler,\n  Handler,\n  Input,\n  MiddlewareHandler,\n  NotFoundHandler,\n  Schema,\n  ToSchema,\n  TypedResponse,\n  ValidationTargets,\n} from 'hono'\nimport type { H, MergePath, MergeSchemaPath } from 'hono/types'\nimport type {\n  ClientErrorStatusCode,\n  InfoStatusCode,\n  RedirectStatusCode,\n  ServerErrorStatusCode,\n  StatusCode,\n  SuccessStatusCode,\n} from 'hono/utils/http-status'\nimport type { JSONParsed, RemoveBlankRecord } from 'hono/utils/types'\nimport { mergePath } from 'hono/utils/url'\nimport type { OpenAPIObject } from 'openapi3-ts/oas30'\nimport type { OpenAPIObject as OpenAPIV31bject } from 'openapi3-ts/oas31'\nimport type { ZodType, ZodError } from 'zod'\nimport { z } from 'zod'\nimport { isZod } from './zod-typeguard'\n\ntype MaybePromise<T> = Promise<T> | T\n\nexport type RouteConfig = RouteConfigBase & {\n  middleware?: H | H[]\n  hide?: boolean\n}\n\ntype RequestTypes = {\n  body?: ZodRequestBody\n  params?: ZodType\n  query?: ZodType\n  cookies?: ZodType\n  headers?: ZodType | ZodType[]\n}\n\ntype IsJson<T> = T extends string\n  ? T extends `application/${infer Start}json${infer _End}`\n    ? Start extends '' | `${string}+` | `vnd.${string}+`\n      ? 'json'\n      : never\n    : never\n  : never\n\ntype IsForm<T> = T extends string\n  ? T extends\n      | `multipart/form-data${infer _Rest}`\n      | `application/x-www-form-urlencoded${infer _Rest}`\n    ? 'form'\n    : never\n  : never\n\ntype ReturnJsonOrTextOrResponse<\n  ContentType,\n  Content,\n  Status extends keyof StatusCodeRangeDefinitions | StatusCode,\n> = ContentType extends string\n  ? ContentType extends `application/${infer Start}json${infer _End}`\n    ? Start extends '' | `${string}+` | `vnd.${string}+`\n      ? TypedResponse<JSONParsed<Content>, ExtractStatusCode<Status>, 'json'>\n      : never\n    : ContentType extends `text/plain${infer _Rest}`\n      ? TypedResponse<Content, ExtractStatusCode<Status>, 'text'>\n      : Response\n  : never\n\ntype RequestPart<R extends RouteConfig, Part extends string> = Part extends keyof R['request']\n  ? R['request'][Part]\n  : {}\n\ntype HasUndefined<T> = undefined extends T ? true : false\n\ntype InputTypeBase<\n  R extends RouteConfig,\n  Part extends string,\n  Type extends keyof ValidationTargets,\n> = R['request'] extends RequestTypes\n  ? RequestPart<R, Part> extends ZodType\n    ? {\n        in: {\n          [K in Type]: HasUndefined<ValidationTargets[K]> extends true\n            ? {\n                [K2 in keyof z.input<RequestPart<R, Part>>]?: z.input<RequestPart<R, Part>>[K2]\n              }\n            : {\n                [K2 in keyof z.input<RequestPart<R, Part>>]: z.input<RequestPart<R, Part>>[K2]\n              }\n        }\n        out: { [K in Type]: z.output<RequestPart<R, Part>> }\n      }\n    : {}\n  : {}\n\ntype InputTypeJson<R extends RouteConfig> = R['request'] extends RequestTypes\n  ? R['request']['body'] extends ZodRequestBody\n    ? R['request']['body']['content'] extends ZodContentObject\n      ? IsJson<keyof R['request']['body']['content']> extends never\n        ? {}\n        : R['request']['body']['content'][keyof R['request']['body']['content']] extends Record<\n              'schema',\n              ZodType<any>\n            >\n          ? {\n              in: {\n                json: z.input<\n                  R['request']['body']['content'][keyof R['request']['body']['content']]['schema']\n                >\n              }\n              out: {\n                json: z.output<\n                  R['request']['body']['content'][keyof R['request']['body']['content']]['schema']\n                >\n              }\n            }\n          : {}\n      : {}\n    : {}\n  : {}\n\ntype InputTypeForm<R extends RouteConfig> = R['request'] extends RequestTypes\n  ? R['request']['body'] extends ZodRequestBody\n    ? R['request']['body']['content'] extends ZodContentObject\n      ? IsForm<keyof R['request']['body']['content']> extends never\n        ? {}\n        : R['request']['body']['content'][keyof R['request']['body']['content']] extends Record<\n              'schema',\n              ZodType<any>\n            >\n          ? {\n              in: {\n                form: z.input<\n                  R['request']['body']['content'][keyof R['request']['body']['content']]['schema']\n                >\n              }\n              out: {\n                form: z.output<\n                  R['request']['body']['content'][keyof R['request']['body']['content']]['schema']\n                >\n              }\n            }\n          : {}\n      : {}\n    : {}\n  : {}\n\ntype InputTypeParam<R extends RouteConfig> = InputTypeBase<R, 'params', 'param'>\ntype InputTypeQuery<R extends RouteConfig> = InputTypeBase<R, 'query', 'query'>\ntype InputTypeHeader<R extends RouteConfig> = InputTypeBase<R, 'headers', 'header'>\ntype InputTypeCookie<R extends RouteConfig> = InputTypeBase<R, 'cookies', 'cookie'>\n\ntype ExtractContent<T> = T extends {\n  [K in keyof T]: infer A\n}\n  ? A extends Record<'schema', ZodType>\n    ? z.infer<A['schema']>\n    : never\n  : never\n\ntype StatusCodeRangeDefinitions = {\n  '1XX': InfoStatusCode\n  '2XX': SuccessStatusCode\n  '3XX': RedirectStatusCode\n  '4XX': ClientErrorStatusCode\n  '5XX': ServerErrorStatusCode\n}\ntype RouteConfigStatusCode = keyof StatusCodeRangeDefinitions | StatusCode\ntype ExtractStatusCode<T extends RouteConfigStatusCode> = T extends keyof StatusCodeRangeDefinitions\n  ? StatusCodeRangeDefinitions[T]\n  : T\ntype DefinedStatusCodes<R extends RouteConfig> = keyof R['responses'] & RouteConfigStatusCode\nexport type RouteConfigToTypedResponse<R extends RouteConfig> =\n  | {\n      [Status in DefinedStatusCodes<R>]: R['responses'][Status] extends { content: infer Content }\n        ? undefined extends Content\n          ? never\n          : ReturnJsonOrTextOrResponse<\n              keyof R['responses'][Status]['content'],\n              ExtractContent<R['responses'][Status]['content']>,\n              Status\n            >\n        : TypedResponse<{}, ExtractStatusCode<Status>, string>\n    }[DefinedStatusCodes<R>]\n  | ('default' extends keyof R['responses']\n      ? R['responses']['default'] extends { content: infer Content }\n        ? undefined extends Content\n          ? never\n          : ReturnJsonOrTextOrResponse<\n              keyof Content,\n              ExtractContent<Content>,\n              Exclude<StatusCode, ExtractStatusCode<DefinedStatusCodes<R>>>\n            >\n        : TypedResponse<{}, Exclude<StatusCode, ExtractStatusCode<DefinedStatusCodes<R>>>, string>\n      : never)\n\nexport type Hook<T, E extends Env, P extends string, R> = (\n  result: { target: keyof ValidationTargets } & (\n    | {\n        success: true\n        data: T\n      }\n    | {\n        success: false\n        error: ZodError\n      }\n  ),\n  c: Context<E, P>\n) => R\n\ntype ConvertPathType<T extends string> = T extends `${infer Start}/{${infer Param}}${infer Rest}`\n  ? `${Start}/:${Param}${ConvertPathType<Rest>}`\n  : T\n\nexport type OpenAPIHonoOptions<E extends Env> = {\n  defaultHook?: Hook<any, E, any, any>\n}\ntype HonoInit<E extends Env> = ConstructorParameters<typeof Hono>[0] & OpenAPIHonoOptions<E>\n\n/**\n * Turns `T | T[] | undefined` into `T[]`\n */\ntype AsArray<T> = T extends undefined // TODO move to utils?\n  ? []\n  : T extends any[]\n    ? T\n    : [T]\n\n/**\n * Like simplify but recursive\n */\nexport type DeepSimplify<T> = {\n  // TODO move to utils?\n  [KeyType in keyof T]: T[KeyType] extends Record<string, unknown>\n    ? DeepSimplify<T[KeyType]>\n    : T[KeyType]\n} & {}\n\n/**\n * Helper to infer generics from {@link MiddlewareHandler}\n */\nexport type OfHandlerType<T extends MiddlewareHandler> =\n  T extends MiddlewareHandler<infer E, infer P, infer I>\n    ? {\n        env: E\n        path: P\n        input: I\n      }\n    : never\n\n/**\n * Reduce a tuple of middleware handlers into a single\n * handler representing the composition of all\n * handlers.\n */\nexport type MiddlewareToHandlerType<M extends MiddlewareHandler<any, any, any>[]> = M extends [\n  infer First,\n  infer Second,\n  ...infer Rest,\n]\n  ? First extends MiddlewareHandler<any, any, any>\n    ? Second extends MiddlewareHandler<any, any, any>\n      ? Rest extends MiddlewareHandler<any, any, any>[] // Ensure Rest is an array of MiddlewareHandler\n        ? MiddlewareToHandlerType<\n            [\n              MiddlewareHandler<\n                DeepSimplify<OfHandlerType<First>['env'] & OfHandlerType<Second>['env']>, // Combine envs\n                OfHandlerType<First>['path'], // Keep path from First\n                OfHandlerType<First>['input'] // Keep input from First\n              >,\n              ...Rest,\n            ]\n          >\n        : never\n      : never\n    : never\n  : M extends [infer Last]\n    ? Last // Return the last remaining handler in the array\n    : MiddlewareHandler<Env>\n\ntype RouteMiddlewareParams<R extends RouteConfig> = OfHandlerType<\n  MiddlewareToHandlerType<AsArray<R['middleware']>>\n>\n\nexport type RouteConfigToEnv<R extends RouteConfig> =\n  RouteMiddlewareParams<R> extends never ? Env : RouteMiddlewareParams<R>['env']\n\nexport type RouteHandler<\n  R extends RouteConfig,\n  E extends Env = RouteConfigToEnv<R>,\n  I extends Input = InputTypeParam<R> &\n    InputTypeQuery<R> &\n    InputTypeHeader<R> &\n    InputTypeCookie<R> &\n    InputTypeForm<R> &\n    InputTypeJson<R>,\n  P extends string = ConvertPathType<R['path']>,\n> = Handler<\n  E,\n  P,\n  I,\n  // If response type is defined, only TypedResponse is allowed.\n  R extends {\n    responses: {\n      [statusCode: number]: {\n        content: {\n          [mediaType: string]: ZodMediaTypeObject\n        }\n      }\n    }\n  }\n    ? MaybePromise<RouteConfigToTypedResponse<R>>\n    : MaybePromise<RouteConfigToTypedResponse<R>> | MaybePromise<Response>\n>\n\nexport type RouteHook<\n  R extends RouteConfig,\n  E extends Env = RouteConfigToEnv<R>,\n  I extends Input = InputTypeParam<R> &\n    InputTypeQuery<R> &\n    InputTypeHeader<R> &\n    InputTypeCookie<R> &\n    InputTypeForm<R> &\n    InputTypeJson<R>,\n  P extends string = ConvertPathType<R['path']>,\n> = Hook<\n  I,\n  E,\n  P,\n  RouteConfigToTypedResponse<R> | Response | Promise<Response> | void | Promise<void>\n>\n\ntype OpenAPIObjectConfig = Parameters<\n  InstanceType<typeof OpenApiGeneratorV3>['generateDocument']\n>[0]\n\nexport type OpenAPIObjectConfigure<E extends Env, P extends string> =\n  | OpenAPIObjectConfig\n  | ((context: Context<E, P>) => OpenAPIObjectConfig)\n\nexport type OpenAPIGeneratorOptions = ConstructorParameters<typeof OpenApiGeneratorV3>[1]\n\nexport type OpenAPIGeneratorConfigure<E extends Env, P extends string> =\n  | OpenAPIGeneratorOptions\n  | ((context: Context<E, P>) => OpenAPIGeneratorOptions)\n\n/**\n * Utility type to convert Hono types to OpenAPIHono types.\n * Replaces Hono return types with OpenAPIHono in function signatures.\n *\n * @example\n * ```ts\n * type MyOpenAPIHono = HonoToOpenAPIHono<Hono<Env>>\n * ```\n */\nexport type HonoToOpenAPIHono<T> =\n  T extends Hono<infer E, infer S, infer B> ? OpenAPIHono<E, S, B> : T\n\n/**\n * Converts a Hono instance to OpenAPIHono type.\n * Use this function to restore the OpenAPIHono type after chaining methods like `get`, `post`, `use`, etc.\n * @example\n * ```ts\n * import { OpenAPIHono, $ } from '@hono/zod-openapi'\n *\n * const app = $(\n *   new OpenAPIHono().use(middleware)\n * )\n * app.openapi(route, handler)\n * ```\n */\nexport const $ = <T extends Hono<any, any, any>>(app: T): HonoToOpenAPIHono<T> => {\n  return app as HonoToOpenAPIHono<T>\n}\n\nexport class OpenAPIHono<\n  E extends Env = Env,\n  S extends Schema = {},\n  BasePath extends string = '/',\n> extends Hono<E, S, BasePath> {\n  openAPIRegistry: OpenAPIRegistry\n  defaultHook?: OpenAPIHonoOptions<E>['defaultHook']\n\n  constructor(init?: HonoInit<E>) {\n    super(init)\n    this.openAPIRegistry = new OpenAPIRegistry()\n    this.defaultHook = init?.defaultHook\n  }\n\n  /**\n   *\n   * @param {RouteConfig} route - The route definition which you create with `createRoute()`.\n   * @param {Handler} handler - The handler. If you want to return a JSON object, you should specify the status code with `c.json()`.\n   * @param {Hook} hook - Optional. The hook method defines what it should do after validation.\n   * @example\n   * app.openapi(\n   *   route,\n   *   (c) => {\n   *     // ...\n   *     return c.json(\n   *       {\n   *         age: 20,\n   *         name: 'Young man',\n   *       },\n   *       200 // You should specify the status code even if it's 200.\n   *     )\n   *   },\n   *  (result, c) => {\n   *    if (!result.success) {\n   *      return c.json(\n   *        {\n   *          code: 400,\n   *          message: 'Custom Message',\n   *        },\n   *        400\n   *      )\n   *    }\n   *  }\n   *)\n   */\n  openapi = <\n    R extends RouteConfig,\n    I extends Input = InputTypeParam<R> &\n      InputTypeQuery<R> &\n      InputTypeHeader<R> &\n      InputTypeCookie<R> &\n      InputTypeForm<R> &\n      InputTypeJson<R>,\n    P extends string = ConvertPathType<R['path']>,\n  >(\n    { middleware: routeMiddleware, hide, ...route }: R,\n    handler: Handler<\n      // use the env from the middleware if it's defined\n      R['middleware'] extends MiddlewareHandler[] | MiddlewareHandler\n        ? RouteMiddlewareParams<R>['env'] & E\n        : E,\n      P,\n      I,\n      // If response type is defined, only TypedResponse is allowed.\n      R extends {\n        responses: {\n          [statusCode: number]: {\n            content: {\n              [mediaType: string]: ZodMediaTypeObject\n            }\n          }\n        }\n      }\n        ? MaybePromise<RouteConfigToTypedResponse<R>>\n        : MaybePromise<RouteConfigToTypedResponse<R>> | MaybePromise<Response>\n    >,\n    hook:\n      | Hook<\n          I,\n          E,\n          P,\n          R extends {\n            responses: {\n              [statusCode: number]: {\n                content: {\n                  [mediaType: string]: ZodMediaTypeObject\n                }\n              }\n            }\n          }\n            ? MaybePromise<RouteConfigToTypedResponse<R>> | undefined\n            : MaybePromise<RouteConfigToTypedResponse<R>> | MaybePromise<Response> | undefined\n        >\n      | undefined = this.defaultHook\n  ): OpenAPIHono<\n    E,\n    S & ToSchema<R['method'], MergePath<BasePath, P>, I, RouteConfigToTypedResponse<R>>,\n    BasePath\n  > => {\n    if (!hide) {\n      this.openAPIRegistry.registerPath(route)\n    }\n\n    const validators: MiddlewareHandler[] = []\n\n    if (route.request?.query) {\n      const validator = zValidator('query', route.request.query as any, hook as any)\n      validators.push(validator as any)\n    }\n\n    if (route.request?.params) {\n      const validator = zValidator('param', route.request.params as any, hook as any)\n      validators.push(validator as any)\n    }\n\n    if (route.request?.headers) {\n      const validator = zValidator('header', route.request.headers as any, hook as any)\n      validators.push(validator as any)\n    }\n\n    if (route.request?.cookies) {\n      const validator = zValidator('cookie', route.request.cookies as any, hook as any)\n      validators.push(validator as any)\n    }\n\n    const bodyContent = route.request?.body?.content\n\n    if (bodyContent) {\n      for (const mediaType of Object.keys(bodyContent)) {\n        if (!bodyContent[mediaType]) {\n          continue\n        }\n        const schema = (bodyContent[mediaType] as ZodMediaTypeObject)['schema']\n        if (!isZod(schema)) {\n          continue\n        }\n        if (isJSONContentType(mediaType)) {\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore we can ignore the type error since Zod Validator's types are not used\n          const validator = zValidator('json', schema, hook) as MiddlewareHandler\n          if (route.request?.body?.required) {\n            validators.push(validator)\n          } else {\n            const mw: MiddlewareHandler = async (c, next) => {\n              if (c.req.header('content-type')) {\n                if (isJSONContentType(c.req.header('content-type')!)) {\n                  return await validator(c, next)\n                }\n              }\n              c.req.addValidatedData('json', {})\n              await next()\n            }\n            validators.push(mw)\n          }\n        }\n        if (isFormContentType(mediaType)) {\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore we can ignore the type error since Zod Validator's types are not used\n          const validator = zValidator('form', schema, hook) as MiddlewareHandler\n          if (route.request?.body?.required) {\n            validators.push(validator)\n          } else {\n            const mw: MiddlewareHandler = async (c, next) => {\n              if (c.req.header('content-type')) {\n                if (isFormContentType(c.req.header('content-type')!)) {\n                  await validator(c, next)\n                  return\n                }\n              }\n              c.req.addValidatedData('form', {})\n              await next()\n            }\n            validators.push(mw)\n          }\n        }\n      }\n    }\n\n    const middleware = routeMiddleware\n      ? Array.isArray(routeMiddleware)\n        ? routeMiddleware\n        : [routeMiddleware]\n      : []\n\n    this.on(\n      [route.method],\n      [route.path.replaceAll(/\\/{(.+?)}/g, '/:$1')],\n      ...middleware,\n      ...validators,\n      handler\n    )\n    return this\n  }\n\n  getOpenAPIDocument = (\n    objectConfig: OpenAPIObjectConfig,\n    generatorConfig?: OpenAPIGeneratorOptions\n  ): OpenAPIObject => {\n    const generator = new OpenApiGeneratorV3(this.openAPIRegistry.definitions, generatorConfig)\n    const document = generator.generateDocument(objectConfig)\n    // @ts-expect-error the _basePath is a private property\n    return this._basePath ? addBasePathToDocument(document, this._basePath) : document\n  }\n\n  getOpenAPI31Document = (\n    objectConfig: OpenAPIObjectConfig,\n    generatorConfig?: OpenAPIGeneratorOptions\n  ): OpenAPIV31bject => {\n    const generator = new OpenApiGeneratorV31(this.openAPIRegistry.definitions, generatorConfig)\n    const document = generator.generateDocument(objectConfig)\n    // @ts-expect-error the _basePath is a private property\n    return this._basePath ? addBasePathToDocument(document, this._basePath) : document\n  }\n\n  doc = <P extends string>(\n    path: P,\n    configureObject: OpenAPIObjectConfigure<E, P>,\n    configureGenerator?: OpenAPIGeneratorConfigure<E, P>\n  ): OpenAPIHono<E, S & ToSchema<'get', MergePath<BasePath, P>, {}, {}>, BasePath> => {\n    return this.get(path, (c) => {\n      const objectConfig =\n        typeof configureObject === 'function' ? configureObject(c) : configureObject\n      const generatorConfig =\n        typeof configureGenerator === 'function' ? configureGenerator(c) : configureGenerator\n      try {\n        const document = this.getOpenAPIDocument(objectConfig, generatorConfig)\n        return c.json(document)\n      } catch (e: any) {\n        return c.json(e, 500)\n      }\n    }) as any\n  }\n\n  doc31 = <P extends string>(\n    path: P,\n    configureObject: OpenAPIObjectConfigure<E, P>,\n    configureGenerator?: OpenAPIGeneratorConfigure<E, P>\n  ): OpenAPIHono<E, S & ToSchema<'get', MergePath<BasePath, P>, {}, {}>, BasePath> => {\n    return this.get(path, (c) => {\n      const objectConfig =\n        typeof configureObject === 'function' ? configureObject(c) : configureObject\n      const generatorConfig =\n        typeof configureGenerator === 'function' ? configureGenerator(c) : configureGenerator\n      try {\n        const document = this.getOpenAPI31Document(objectConfig, generatorConfig)\n        return c.json(document)\n      } catch (e: any) {\n        return c.json(e, 500)\n      }\n    }) as any\n  }\n\n  route<\n    SubPath extends string,\n    SubEnv extends Env,\n    SubSchema extends Schema,\n    SubBasePath extends string,\n  >(\n    path: SubPath,\n    app: Hono<SubEnv, SubSchema, SubBasePath>\n  ): OpenAPIHono<E, MergeSchemaPath<SubSchema, MergePath<BasePath, SubPath>> & S, BasePath>\n  route<SubPath extends string>(path: SubPath): Hono<E, RemoveBlankRecord<S>, BasePath>\n  route<\n    SubPath extends string,\n    SubEnv extends Env,\n    SubSchema extends Schema,\n    SubBasePath extends string,\n  >(\n    path: SubPath,\n    app?: Hono<SubEnv, SubSchema, SubBasePath>\n  ): OpenAPIHono<E, MergeSchemaPath<SubSchema, MergePath<BasePath, SubPath>> & S, BasePath> {\n    const pathForOpenAPI = path.replaceAll(/:([^\\/]+)/g, '{$1}')\n    super.route(path, app as any)\n\n    if (!(app instanceof OpenAPIHono)) {\n      return this as any\n    }\n\n    app.openAPIRegistry.definitions.forEach((def) => {\n      switch (def.type) {\n        case 'component':\n          return this.openAPIRegistry.registerComponent(def.componentType, def.name, def.component)\n\n        case 'route': {\n          this.openAPIRegistry.registerPath({\n            ...def.route,\n            path: mergePath(\n              pathForOpenAPI,\n              // @ts-expect-error _basePath is private\n              app._basePath.replaceAll(/:([^\\/]+)/g, '{$1}'),\n              def.route.path\n            ),\n          })\n          return\n        }\n\n        case 'webhook': {\n          this.openAPIRegistry.registerWebhook({\n            ...def.webhook,\n            path: mergePath(\n              pathForOpenAPI,\n              // @ts-expect-error _basePath is private\n              app._basePath.replaceAll(/:([^\\/]+)/g, '{$1}'),\n              def.webhook.path\n            ),\n          })\n          return\n        }\n\n        case 'schema':\n          return this.openAPIRegistry.register(\n            getOpenApiMetadata(def.schema)._internal?.refId,\n            def.schema\n          )\n\n        case 'parameter':\n          return this.openAPIRegistry.registerParameter(\n            getOpenApiMetadata(def.schema)._internal?.refId,\n            def.schema\n          )\n\n        default: {\n          const errorIfNotExhaustive: never = def\n          throw new Error(`Unknown registry type: ${errorIfNotExhaustive}`)\n        }\n      }\n    })\n\n    return this as any\n  }\n\n  basePath<SubPath extends string>(path: SubPath): OpenAPIHono<E, S, MergePath<BasePath, SubPath>> {\n    return new OpenAPIHono({ ...(super.basePath(path) as any), defaultHook: this.defaultHook })\n  }\n\n  // Type overrides to return OpenAPIHono instead of Hono\n  declare onError: (handler: ErrorHandler<E>) => OpenAPIHono<E, S, BasePath>\n  declare notFound: (handler: NotFoundHandler<E>) => OpenAPIHono<E, S, BasePath>\n}\n\ntype RoutingPath<P extends string> = P extends `${infer Head}/{${infer Param}}${infer Tail}`\n  ? `${Head}/:${Param}${RoutingPath<Tail>}`\n  : P\n\nexport const createRoute = <P extends string, R extends Omit<RouteConfig, 'path'> & { path: P }>(\n  routeConfig: R\n): R & {\n  getRoutingPath(): RoutingPath<R['path']>\n} => {\n  const route = {\n    ...routeConfig,\n    getRoutingPath(): RoutingPath<R['path']> {\n      return routeConfig.path.replaceAll(/\\/{(.+?)}/g, '/:$1') as RoutingPath<P>\n    },\n  }\n  return Object.defineProperty(route, 'getRoutingPath', { enumerable: false })\n}\n\nextendZodWithOpenApi(z)\nexport { extendZodWithOpenApi, z }\n\nfunction addBasePathToDocument(document: Record<string, any>, basePath: string) {\n  const updatedPaths: Record<string, any> = {}\n\n  Object.keys(document.paths).forEach((path) => {\n    updatedPaths[mergePath(basePath.replaceAll(/:([^\\/]+)/g, '{$1}'), path)] = document.paths[path]\n  })\n\n  return {\n    ...document,\n    paths: updatedPaths,\n  }\n}\n\nfunction isJSONContentType(contentType: string) {\n  return /^application\\/([a-z-\\.]+\\+)?json/.test(contentType)\n}\n\nfunction isFormContentType(contentType: string) {\n  return (\n    contentType.startsWith('multipart/form-data') ||\n    contentType.startsWith('application/x-www-form-urlencoded')\n  )\n}\n"],"mappings":"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"}